1. client(웹브라우저) => 서버로 요청
2. 서버에는 세션 저장소에 client에 맞는 세션 ID를 만들어 넣는다.
3. 서버는 header에 세션ID로(자바일경우) 웹브라우저에 보내줌
4. 웹브라우저 내부에 쿠키에 세션 ID를 저장함
5. 웹브라우저는 그 다음부터 세션 ID를 header에 담아서 서버로 보낸다.

tip..) 세션을 서버에서 종료하는법
- 서버종료
- 브라우저 종료
- 특정 시간이 지나면 서버에서 사라짐

title : 세션 단점
- 로드밸런싱 될때 문제가 됨. why? 요청이 여러 서버에 접속이 된다면 로그인 했음에도 다른 서버에 세션 정보가 저장됨
- 그러면 DB로 세션 정보를 저장하고 여러서버에서 디비를 바라보면 되는거 아닌가라는 생각을 할수 있지만 성능 저하 발생
- cpu가 DB에 접속할때 I/O가 발생하고 이때 100만배 느려진다고 함. 
- cpu -> ram -> hdd 순으로 가는데 ram은 cpu가 직접 액세스가 가능하기 때문에 빠른데 hdd는 직접 액세스가 불가능 하므로 느리다.
- 그래서 메모리 공유 서버를 쓴다 (redis,...)

title : OSI 7계층

- 응용 : 롤 게임에서 액션이 일어남 ( 야스오 궁 ㅋㅋ.....)
- 프리젠테이션 : 야스오 궁에 대한 데이터를 암호화 , 만약 데이터가 크다면 압축 ....
- 세션계층 : 응용 프로그램들 사이의 접속을 설정하고 유지하는 등의 역할을 함
- 트랜스포트 : TCP/UDP
- 네트워크 : IP(보통 공유기 까지)
- 데이터링크 : 공유기(NAN)에서 실제 보내는 데이터 찾기
- 물리 : 전송선 

title : CIA

C : 기밀성
I : 무결성(변경 x)
A : 가용성

A나라에서 B나라로 문서를 보내는데 C나라에서 문서를 중간에서 가로채거나 문서를 위조하거나 문서를 보거나 그러면 CIA가 깨짐

일반적인 문서를 그냥 보내면 CIA가 깨질 확률이 높다.

기밀성 높이는 방법 
1. 최고의 전사를 보내면 된다.
2. 문서를 암호화한다.(전사가 죽어서 문서가 뺏길수는 있지만 암호화되어있어 안전함)

문제
- 열쇠전달의 문제 (데이터를 보낼때 암호화 한 상태로 보내는데 받는 입장에서도 해독할 키가 필요함)
- 문서 : 누구로부터 왔는가 ( 문서는 중간에서 위조될 수 있으니 )

title : RSA

공개키 : 누구나 알수 있는키 (오픈해도 되는것)
개인키 : 자기만 알아야 하는키 (오픈해서 안되는것)

A의 공개키 , 개인키
B의 공개키 , 개인키 

A->B로 데이터를 전송한다면! 
전자상에서 서명 즉 인증 방식 : 개인키로 잠구는것 ( A에서 A개인키로 잠구고 -> B에서 A의 공개키로 열어본다 )
전자상에서 암호화가 되는것 : 공개키로 잠구는것 ( A에서 B의 공개키로 잠구고 -> B에서 B의 개인키로 열어본다. )

A에서 B로 데이터(1234란)를 보낼때 1234 데이터를 B의 공개키로 암호화를 시키고
A의 개인키로 서명을 한번더 한다.

원리) A -> B로 데이터를 보냈다고 한다면
1. B가 문서를 받으면
2. A의 공개키로 열어본다. 
   1. 열린다면 인증 받았다
   2. 열리지 않는다면 인증 받지 않았다.
3. B의 개인키를 열어본다.

title : RFC

네트워크 간의 연결을 하기 위해 서로의 약속을 정하고자 점점 만들어가는것 RFC
www : RFC의 문서로 이루어져있다고 해도 무방
JWT는 RFC 7519번 문서에 존재하는 내용이다.